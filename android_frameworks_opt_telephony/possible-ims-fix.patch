From bdff3f94428c8622ff3ba67aba92b86d5210acd5 Mon Sep 17 00:00:00 2001
From: maxwen <max.weninger@gmail.com>
Date: Wed, 20 Dec 2017 14:53:11 +0100
Subject: [PATCH 1/7] telephony: Fix loading of non Oreo-MR1 QTI blobs

 * Pre Oreo-MR1 QTI blobs will get NullPointerExceptions otherwise

Example:
01-25 10:45:20.687  3706  3706 E AndroidRuntime: FATAL EXCEPTION: main
01-25 10:45:20.687  3706  3706 E AndroidRuntime: Process: com.android.phone, PID: 3706
01-25 10:45:20.687  3706  3706 E AndroidRuntime: java.lang.NullPointerException: Attempt to invoke virtual method 'void com.qualcomm.qti.internal.telephony.QtiSubsc
riptionInfoUpdater.addSubInfoRecord(int, java.lang.String)' on a null object reference
01-25 10:45:20.687  3706  3706 E AndroidRuntime:        at com.qualcomm.qti.internal.telephony.QtiUiccCardProvisioner.queryUiccProvisionInfo(QtiUiccCardProvisioner.java:3
47)
01-25 10:45:20.687  3706  3706 E AndroidRuntime:        at com.qualcomm.qti.internal.telephony.QtiUiccCardProvisioner.handleUnsolManualProvisionEvent(QtiUiccCardProvision
er.java:296)
01-25 10:45:20.687  3706  3706 E AndroidRuntime:        at com.qualcomm.qti.internal.telephony.QtiUiccCardProvisioner.handleMessage(QtiUiccCardProvisioner.java:240)
01-25 10:45:20.687  3706  3706 E AndroidRuntime:        at android.os.Handler.dispatchMessage(Handler.java:106)
01-25 10:45:20.687  3706  3706 E AndroidRuntime:        at android.os.Looper.loop(Looper.java:164)
01-25 10:45:20.687  3706  3706 E AndroidRuntime:        at android.app.ActivityThread.main(ActivityThread.java:6501)
01-25 10:45:20.687  3706  3706 E AndroidRuntime:        at java.lang.reflect.Method.invoke(Native Method)
01-25 10:45:20.687  3706  3706 E AndroidRuntime:        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)
01-25 10:45:20.687  3706  3706 E AndroidRuntime:        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)
---
 src/java/com/android/internal/telephony/PhoneFactory.java   | 2 +-
 .../android/internal/telephony/SubscriptionInfoUpdater.java | 6 ++++++
 .../internal/telephony/TelephonyComponentFactory.java       | 6 ++++--
 3 files changed, 11 insertions(+), 3 deletions(-)

diff --git a/src/java/com/android/internal/telephony/PhoneFactory.java b/src/java/com/android/internal/telephony/PhoneFactory.java
index 512e8a87b..3a51fec97 100644
--- a/src/java/com/android/internal/telephony/PhoneFactory.java
+++ b/src/java/com/android/internal/telephony/PhoneFactory.java
@@ -228,7 +228,7 @@ public class PhoneFactory {
 
                 Rlog.i(LOG_TAG, "Creating SubInfoRecordUpdater ");
                 sSubInfoRecordUpdater = telephonyComponentFactory.makeSubscriptionInfoUpdater(
-                        BackgroundThread.get().getLooper(), context, sPhones, sCommandsInterfaces);
+                        context, sPhones, sCommandsInterfaces);
                 SubscriptionController.getInstance().updatePhonesAvailability(sPhones);
 
                 // Start monitoring after defaults have been made.
diff --git a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
index a205d1466..00de55df1 100644
--- a/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
+++ b/src/java/com/android/internal/telephony/SubscriptionInfoUpdater.java
@@ -53,6 +53,7 @@ import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.telephony.euicc.EuiccController;
 import com.android.internal.telephony.uicc.IccRecords;
 import com.android.internal.telephony.uicc.IccUtils;
+import com.android.internal.os.BackgroundThread;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
@@ -142,6 +143,11 @@ public class SubscriptionInfoUpdater extends Handler {
         initializeCarrierApps();
     }
 
+    public SubscriptionInfoUpdater(Context context, Phone[] phone, CommandsInterface[] ci) {
+        this(BackgroundThread.get().getLooper(), context, phone, ci);
+
+    }
+
     private void initializeCarrierApps() {
         // Initialize carrier apps:
         // -Now (on system startup)
diff --git a/src/java/com/android/internal/telephony/TelephonyComponentFactory.java b/src/java/com/android/internal/telephony/TelephonyComponentFactory.java
index bda132272..b76d50ac4 100644
--- a/src/java/com/android/internal/telephony/TelephonyComponentFactory.java
+++ b/src/java/com/android/internal/telephony/TelephonyComponentFactory.java
@@ -35,6 +35,8 @@ import com.android.internal.telephony.SubscriptionController;
 import com.android.internal.telephony.uicc.IccCardStatus;
 import com.android.internal.telephony.uicc.UiccCard;
 import com.android.internal.telephony.uicc.UiccProfile;
+import com.android.internal.os.BackgroundThread;
+
 
 import dalvik.system.PathClassLoader;
 
@@ -238,10 +240,10 @@ public class TelephonyComponentFactory {
         return SubscriptionController.init(c, ci);
     }
 
-    public SubscriptionInfoUpdater makeSubscriptionInfoUpdater(Looper looper, Context context,
+    public SubscriptionInfoUpdater makeSubscriptionInfoUpdater(Context context,
             Phone[] phones, CommandsInterface[] ci) {
         Rlog.d(LOG_TAG, "makeSubscriptionInfoUpdater");
-        return new SubscriptionInfoUpdater(looper, context, phones, ci);
+        return new SubscriptionInfoUpdater(BackgroundThread.get().getLooper(), context, phones, ci);
     }
 
     public void makeExtTelephonyClasses(Context context,
-- 
2.19.1


From 8f2e5148cfaf1258da14153ff7566e8d5139dacf Mon Sep 17 00:00:00 2001
From: Umashankar Godachi <umasha@codeaurora.org>
Date: Tue, 15 May 2018 15:21:27 +0530
Subject: [PATCH 2/7] MSIM: Fix to refresh active subscription info cache.

During hotswap, active subscription info cache needs
to be refreshed, but currently refresh is happening even
before slotId to subId mapping is done resulting in stale
data getting retrieved.

Fix: Refresh active subscription info cache only after slotId
     to subId mapping is done.

Change-Id: Ie06c804e28af16a9cfb3c47fd4d32c5f5968930c
CRs-Fixed: 2228217
Signed-off-by: Pranav Vashi <neobuddy89@gmail.com>
---
 .../internal/telephony/SubscriptionController.java   | 12 +++---------
 1 file changed, 3 insertions(+), 9 deletions(-)

diff --git a/src/java/com/android/internal/telephony/SubscriptionController.java b/src/java/com/android/internal/telephony/SubscriptionController.java
index 4ff63b70d..d3bd3a595 100644
--- a/src/java/com/android/internal/telephony/SubscriptionController.java
+++ b/src/java/com/android/internal/telephony/SubscriptionController.java
@@ -955,9 +955,6 @@ public class SubscriptionController extends ISub.Stub {
                         resolver.update(SubscriptionManager.CONTENT_URI, value,
                                 SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID +
                                         "=" + Long.toString(subId), null);
-
-                        // Refresh the Cache of Active Subscription Info List
-                        refreshCachedActiveSubscriptionInfoList();
                     }
 
                     if (DBG) logdl("[addSubInfoRecord] Record already exists");
@@ -1051,12 +1048,12 @@ public class SubscriptionController extends ISub.Stub {
                         SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID +
                                 "=" + Long.toString(subId), null);
 
-                // Refresh the Cache of Active Subscription Info List
-                refreshCachedActiveSubscriptionInfoList();
-
                 if (DBG) logdl("[addSubInfoRecord] sim name = " + nameToSet);
             }
 
+            // Refresh the Cache of Active Subscription Info List
+            refreshCachedActiveSubscriptionInfoList();
+
             // Once the records are loaded, notify DcTracker
             sPhones[slotIndex].updateDataConnectionTracker();
 
@@ -1100,9 +1097,6 @@ public class SubscriptionController extends ISub.Stub {
 
         Uri uri = resolver.insert(SubscriptionManager.CONTENT_URI, value);
 
-        // Refresh the Cache of Active Subscription Info List
-        refreshCachedActiveSubscriptionInfoList();
-
         return uri;
     }
 
-- 
2.19.1


From f75d2d77aee4084e9dc1688b44f420308f5097a3 Mon Sep 17 00:00:00 2001
From: Vidyalakshmi Badiger <badige@codeaurora.org>
Date: Mon, 23 Jul 2018 14:27:38 +0530
Subject: [PATCH 3/7] Fix iccid issue during android upgrade.

Use fulliccid instead of stripped iccid so that the sub info
record matches.

Change-Id: Ic72c8b632ec691b4c6d99f70efb3168fd6bb653c
CRs-Fixed: 2281438
Signed-off-by: Pranav Vashi <neobuddy89@gmail.com>
---
 .../telephony/SubscriptionController.java       | 17 +++++++++++++----
 1 file changed, 13 insertions(+), 4 deletions(-)

diff --git a/src/java/com/android/internal/telephony/SubscriptionController.java b/src/java/com/android/internal/telephony/SubscriptionController.java
index d3bd3a595..a8f180727 100644
--- a/src/java/com/android/internal/telephony/SubscriptionController.java
+++ b/src/java/com/android/internal/telephony/SubscriptionController.java
@@ -895,6 +895,12 @@ public class SubscriptionController extends ISub.Stub {
      */
     @Override
     public int addSubInfoRecord(String iccId, int slotIndex) {
+        String fullIccId = iccId;
+        Phone phone = PhoneFactory.getPhone(slotIndex);
+        if (phone != null) {
+            fullIccId = phone.getFullIccSerialNumber();
+        }
+
         if (DBG) logdl("[addSubInfoRecord]+ iccId:" + SubscriptionInfo.givePrintableIccid(iccId) +
                 " slotIndex:" + slotIndex);
 
@@ -913,8 +919,10 @@ public class SubscriptionController extends ISub.Stub {
                     new String[]{SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID,
                             SubscriptionManager.SIM_SLOT_INDEX, SubscriptionManager.NAME_SOURCE,
                             SubscriptionManager.ICC_ID, SubscriptionManager.CARD_ID},
-                    SubscriptionManager.ICC_ID + "=?" + " OR " + SubscriptionManager.ICC_ID + "=?",
-                            new String[]{iccId, IccUtils.getDecimalSubstring(iccId)}, null);
+                    SubscriptionManager.ICC_ID + "=?" + " OR " + SubscriptionManager.ICC_ID + "=?"
+                             + " OR " + SubscriptionManager.ICC_ID + "=?" + " collate nocase",
+                            new String[]{iccId, IccUtils.getDecimalSubstring(iccId), fullIccId},
+                            null);
 
             boolean setDisplayName = false;
             try {
@@ -938,8 +946,9 @@ public class SubscriptionController extends ISub.Stub {
                         setDisplayName = true;
                     }
 
-                    if (oldIccId != null && oldIccId.length() < iccId.length()
-                            && (oldIccId.equals(IccUtils.getDecimalSubstring(iccId)))) {
+                    if (oldIccId != null && oldIccId.length() != iccId.length()
+                           && (oldIccId.equals(IccUtils.getDecimalSubstring(iccId))
+                                    || iccId.equals(IccUtils.stripTrailingFs(oldIccId)))) {
                         value.put(SubscriptionManager.ICC_ID, iccId);
                     }
 
-- 
2.19.1


From 72f11dfaad7085e9125cb0be3d770f61e6be2480 Mon Sep 17 00:00:00 2001
From: Vidyalakshmi Badiger <badige@codeaurora.org>
Date: Fri, 24 Aug 2018 12:11:03 +0530
Subject: [PATCH 4/7] MSIM:Fix iccid issue during android upgrade.

To resolve IllegalArgumentException ,add cardstate check and later
use the ICCID which received as part of addSubInfoRecord() when
Phone.getFullIccSerialNumber() returns null ICCID value.

Change-Id: If1eed8beb4e4db2b782184046f18ab4dd2bfc6de
CRs-Fixed: 2300837
Signed-off-by: Pranav Vashi <neobuddy89@gmail.com>
---
 .../internal/telephony/SubscriptionController.java  | 13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

diff --git a/src/java/com/android/internal/telephony/SubscriptionController.java b/src/java/com/android/internal/telephony/SubscriptionController.java
index a8f180727..2437a8dbb 100644
--- a/src/java/com/android/internal/telephony/SubscriptionController.java
+++ b/src/java/com/android/internal/telephony/SubscriptionController.java
@@ -895,10 +895,17 @@ public class SubscriptionController extends ISub.Stub {
      */
     @Override
     public int addSubInfoRecord(String iccId, int slotIndex) {
-        String fullIccId = iccId;
+        String fullIccId;
         Phone phone = PhoneFactory.getPhone(slotIndex);
-        if (phone != null) {
+        UiccCard uiccCard = UiccController.getInstance().getUiccCardForSlot(slotIndex);
+        if (phone != null && uiccCard != null) {
             fullIccId = phone.getFullIccSerialNumber();
+            if (TextUtils.isEmpty(fullIccId)) {
+                fullIccId = iccId;
+            }
+        } else {
+            if (DBG) logdl("[addSubInfoRecord]- null fullIccId");
+            return -1;
         }
 
         if (DBG) logdl("[addSubInfoRecord]+ iccId:" + SubscriptionInfo.givePrintableIccid(iccId) +
@@ -948,7 +955,7 @@ public class SubscriptionController extends ISub.Stub {
 
                     if (oldIccId != null && oldIccId.length() != iccId.length()
                            && (oldIccId.equals(IccUtils.getDecimalSubstring(iccId))
-                                    || iccId.equals(IccUtils.stripTrailingFs(oldIccId)))) {
+                           || iccId.equalsIgnoreCase(IccUtils.stripTrailingFs(oldIccId)))) {
                         value.put(SubscriptionManager.ICC_ID, iccId);
                     }
 
-- 
2.19.1


From 5a89b557ec35fad206db83f336b466ee2c1e60e5 Mon Sep 17 00:00:00 2001
From: Ruthwar Ambeer <rambeer@codeaurora.org>
Date: Thu, 9 Nov 2017 18:04:00 +0530
Subject: [PATCH 5/7] Update proper country code to WifiService.

If the device is dsds configured, country code gets
updated from Telephony twice. And if the service is
lost in any of the sub, ServicestateTracker will
overwrite the country code (set by another sub) with
no country.

Fix is not to overwrite If the country code is
already set by previous sub and current sub doesnt
have network operator info.

Change-Id: Ie0178bd20e8b1edb03761bec051fa607626cf8dd
CRs-Fixed: 2206253
Signed-off-by: Pranav Vashi <neobuddy89@gmail.com>
---
 .../android/internal/telephony/MccTable.java  | 31 +++++++++++++++++++
 1 file changed, 31 insertions(+)

diff --git a/src/java/com/android/internal/telephony/MccTable.java b/src/java/com/android/internal/telephony/MccTable.java
index a0106182b..79823a1fa 100644
--- a/src/java/com/android/internal/telephony/MccTable.java
+++ b/src/java/com/android/internal/telephony/MccTable.java
@@ -23,6 +23,7 @@ import android.net.wifi.WifiManager;
 import android.os.Build;
 import android.os.RemoteException;
 import android.os.SystemProperties;
+import android.telephony.SubscriptionManager;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
 import android.util.Slog;
@@ -396,6 +397,12 @@ public final class MccTable {
         return locale;
     }
 
+    private static boolean isInvalidOperatorNumeric(String operatorNumeric) {
+        return operatorNumeric == null
+                || operatorNumeric.length() < 5
+                || operatorNumeric.startsWith("000");
+    }
+
     /**
      * Set the country code for wifi.  This sets allowed wifi channels based on the
      * country of the carrier we see.  If we can't see any, reset to 0 so we don't
@@ -404,6 +411,30 @@ public final class MccTable {
      * @param mcc Mobile Country Code of the operator.  0 if not known
      */
     private static void setWifiCountryCodeFromMcc(Context context, int mcc) {
+        final SubscriptionManager subscriptionManager = SubscriptionManager.from(context);
+        final TelephonyManager tm = TelephonyManager.from(context);
+        Slog.d(LOG_TAG, "setWifiCountryCodeFromMcc mcc = " + mcc);
+        int[] subIds = subscriptionManager.getActiveSubscriptionIdList();
+        int phoneId = 0;
+        boolean isValidOnAnySub = false;
+        // Prior to update the "no country" status to wifi service if it is invalid,
+        // Check If any SUB already has valid operator numeric. If it is
+        // found ignore the current SUB's empty or invalid operator numeric.
+        if (mcc == 0 && subIds != null && subIds.length > 0) {
+            for (int subId : subIds) {
+                phoneId = SubscriptionController.getInstance().getPhoneId(subId);
+                String operatorNumeric = tm.getNetworkOperatorForPhone(phoneId);
+                if (!isInvalidOperatorNumeric(operatorNumeric)) {
+                    Slog.d(LOG_TAG, "operatornumeric is valid, "
+                            + "Do not overwrite");
+                    isValidOnAnySub = true;
+                    break;
+                }
+            }
+            if (isValidOnAnySub) {
+                return;
+            }
+        }
         String country = MccTable.countryCodeForMcc(mcc);
         Slog.d(LOG_TAG, "WIFI_COUNTRY_CODE set to " + country);
         WifiManager wM = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
-- 
2.19.1


From 4ea327dd312f207a9180d98bf7eeb9889ee714fc Mon Sep 17 00:00:00 2001
From: Venkat Ram Prakash Kotni <vkotni@codeaurora.org>
Date: Thu, 18 Jul 2013 13:08:13 -0700
Subject: [PATCH 6/7] Support Fetching IMSI MCC and MNC for RuimRecords.

The Following changes are done with this.

- Read IMSI using SIM I/O for CSIM/RUIM.

Use Sim I/O command to read the EF_IMSIM to retrieve the IMSI
from the card, rather than using CommandsInterface.getIMSIForApp.
When both SIM and RUIM app exists, we cannot specify the
application for which we should retrieve the IMSI using the getIMSI
API, since SIM and RUIM have no AID.

- Change to return proper MNC in case of CSIM.

As per spec C.S0065 section 5.2.2 MNC length in case of CSIM
IMSI is 2. So modify the code to return the MNC of proper length.

- Introduce getOperatorNumeric api in RuimRecords

Since the DcTracker uses Generalized API
getOperatorNumeric for both SimRecords and
RuimRecords, Introduces same API in RuimRecords
which indirectly invoke getRuimOperatorNumeric

Change-Id: I905d4a271dfba168f2bc3830b8a50733cbe17f8c
CRs-fixed: 514270,656508
Signed-off-by: Pranav Vashi <neobuddy89@gmail.com>
---
 .../internal/telephony/uicc/RuimRecords.java  | 154 ++++++++++--------
 1 file changed, 86 insertions(+), 68 deletions(-)

diff --git a/src/java/com/android/internal/telephony/uicc/RuimRecords.java b/src/java/com/android/internal/telephony/uicc/RuimRecords.java
index 88ac071cc..9a9435a8a 100644
--- a/src/java/com/android/internal/telephony/uicc/RuimRecords.java
+++ b/src/java/com/android/internal/telephony/uicc/RuimRecords.java
@@ -84,8 +84,11 @@ public class RuimRecords extends IccRecords {
                 + " mHomeNetworkId=" + mHomeNetworkId;
     }
 
+    // Constants
+    // MNC length in case of CSIM/RUIM IMSI is 2 as per spec C.S0065 section 5.2.2
+    private static final int CSIM_IMSI_MNC_LENGTH = 2;
+
     // ***** Event Constants
-    private static final int EVENT_GET_IMSI_DONE = 3;
     private static final int EVENT_GET_DEVICE_IDENTITY_DONE = 4;
     private static final int EVENT_GET_ICCID_DONE = 5;
     private static final int EVENT_GET_CDMA_SUBSCRIPTION_DONE = 10;
@@ -203,15 +206,66 @@ public class RuimRecords extends IccRecords {
         }
     }
 
-    private int adjstMinDigits (int digits) {
+    private int decodeImsiDigits(int digits, int length) {
         // Per C.S0005 section 2.3.1.
-        digits += 111;
-        digits = (digits % 10 == 0)?(digits - 10):digits;
-        digits = ((digits / 10) % 10 == 0)?(digits - 100):digits;
-        digits = ((digits / 100) % 10 == 0)?(digits - 1000):digits;
+        int constant = 0;
+        for (int i = 0; i < length; i++) {
+            constant = (constant * 10) + 1;
+        }
+
+        digits += constant;
+
+        for (int i = 0, denominator = 1; i < length; i++) {
+            digits = ((digits / denominator) % 10 == 0) ? (digits - (10 * denominator)) : digits;
+            denominator *= 10;
+        }
         return digits;
     }
 
+    /**
+     * Decode utility to decode IMSI from data read from EF_IMSIM
+     * Please refer to
+     *       // C.S0065 section 5.2.2 for IMSI_M encoding
+     *       // C.S0005 section 2.3.1 for MIN encoding in IMSI_M.
+     */
+    private String decodeImsi(byte[] data) {
+        // Retrieve the MCC and digits 11 and 12
+        int mcc_data = ((0x03 & data[9]) << 8) | (0xFF & data[8]);
+        int mcc = decodeImsiDigits(mcc_data, 3);
+        int digits_11_12_data = data[6] & 0x7f;
+        int digits_11_12 = decodeImsiDigits(digits_11_12_data, 2);
+
+        // Retrieve 10 MIN digits
+        int first3digits = ((0x03 & data[2]) << 8) + (0xFF & data[1]);
+        int second3digits = (((0xFF & data[5]) << 8) | (0xFF & data[4])) >> 6;
+        int digit7 = 0x0F & (data[4] >> 2);
+        if (digit7 > 0x09) digit7 = 0;
+        int last3digits = ((0x03 & data[4]) << 8) | (0xFF & data[3]);
+
+        first3digits = decodeImsiDigits(first3digits, 3);
+        second3digits = decodeImsiDigits(second3digits, 3);
+        last3digits = decodeImsiDigits(last3digits, 3);
+
+        StringBuilder builder = new StringBuilder();
+        builder.append(String.format(Locale.US, "%03d", mcc));
+        builder.append(String.format(Locale.US, "%02d", digits_11_12));
+        builder.append(String.format(Locale.US, "%03d", first3digits));
+        builder.append(String.format(Locale.US, "%03d", second3digits));
+        builder.append(String.format(Locale.US, "%d", digit7));
+        builder.append(String.format(Locale.US, "%03d", last3digits));
+        return  builder.toString();
+    }
+
+     /**
+     * Introduce Generic API returns the 5 or 6 digit MCC/MNC
+     * of the operator that provided the RUIM card.
+     * Returns null of RUIM is not yet ready
+     */
+    @Override
+    public String getOperatorNumeric() {
+        return getRUIMOperatorNumeric();
+    }
+
     /**
      * Returns the 5 or 6 digit MCC/MNC of the operator that
      *  provided the RUIM card. Returns null of RUIM is not yet ready
@@ -229,11 +283,7 @@ public class RuimRecords extends IccRecords {
             return imsi.substring(0, 3 + mMncLength);
         }
 
-        // Guess the MNC length based on the MCC if we don't
-        // have a valid value in ef[ad]
-
-        int mcc = Integer.parseInt(imsi.substring(0, 3));
-        return imsi.substring(0, 3 + MccTable.smallestDigitsMccForMnc(mcc));
+        return mImsi.substring(0, 3 + CSIM_IMSI_MNC_LENGTH);
     }
 
     // Refer to ETSI TS 102.221
@@ -378,31 +428,39 @@ public class RuimRecords extends IccRecords {
         @Override
         public void onRecordLoaded(AsyncResult ar) {
             byte[] data = (byte[]) ar.result;
+
+            if (data == null || data.length < 10) {
+                log("Invalid IMSI from EF_CSIM_IMSIM " + IccUtils.bytesToHexString(data));
+                mImsi = null;
+                mMin = null;
+                return;
+            }
             if (VDBG) log("CSIM_IMSIM=" + IccUtils.bytesToHexString(data));
+
             // C.S0065 section 5.2.2 for IMSI_M encoding
             // C.S0005 section 2.3.1 for MIN encoding in IMSI_M.
             boolean provisioned = ((data[7] & 0x80) == 0x80);
 
             if (provisioned) {
-                int first3digits = ((0x03 & data[2]) << 8) + (0xFF & data[1]);
-                int second3digits = (((0xFF & data[5]) << 8) | (0xFF & data[4])) >> 6;
-                int digit7 = 0x0F & (data[4] >> 2);
-                if (digit7 > 0x09) digit7 = 0;
-                int last3digits = ((0x03 & data[4]) << 8) | (0xFF & data[3]);
-                first3digits = adjstMinDigits(first3digits);
-                second3digits = adjstMinDigits(second3digits);
-                last3digits = adjstMinDigits(last3digits);
-
-                StringBuilder builder = new StringBuilder();
-                builder.append(String.format(Locale.US, "%03d", first3digits));
-                builder.append(String.format(Locale.US, "%03d", second3digits));
-                builder.append(String.format(Locale.US, "%d", digit7));
-                builder.append(String.format(Locale.US, "%03d", last3digits));
-                mMin = builder.toString();
-                if (DBG) log("min present=" + mMin);
+                mImsi = decodeImsi(data);
+                if (null != mImsi) {
+                    mMin = mImsi.substring(5, 15);
+                }
+                if (DBG) log("IMSI: " + mImsi.substring(0, 5) + "xxxxxxxxx");
+
             } else {
-                if (DBG) log("min not present");
+                if (DBG) log("IMSI not provisioned in card");
+            }
+
+            // Update MccTable with the retrieved IMSI
+            String operatorNumeric = getOperatorNumeric();
+            if (operatorNumeric != null) {
+                if (operatorNumeric.length() <= 6) {
+                    MccTable.updateMccMncConfiguration(mContext, operatorNumeric, false);
+                }
             }
+
+            mImsiReadyRegistrants.notifyRegistrants();
         }
     }
 
@@ -618,43 +676,6 @@ public class RuimRecords extends IccRecords {
                 log("Event EVENT_GET_DEVICE_IDENTITY_DONE Received");
             break;
 
-            /* IO events */
-            case EVENT_GET_IMSI_DONE:
-                isRecordLoadResponse = true;
-
-                ar = (AsyncResult)msg.obj;
-                if (ar.exception != null) {
-                    loge("Exception querying IMSI, Exception:" + ar.exception);
-                    break;
-                }
-
-                mImsi = (String) ar.result;
-
-                // IMSI (MCC+MNC+MSIN) is at least 6 digits, but not more
-                // than 15 (and usually 15).
-                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
-                    loge("invalid IMSI " + mImsi);
-                    mImsi = null;
-                }
-
-                // FIXME: CSIM IMSI may not contain the MNC.
-                if (false) {
-                    log("IMSI: " + mImsi.substring(0, 6) + "xxxxxxxxx");
-
-                    String operatorNumeric = getRUIMOperatorNumeric();
-                    if (operatorNumeric != null) {
-                        if (operatorNumeric.length() <= 6) {
-                            log("update mccmnc=" + operatorNumeric);
-                            MccTable.updateMccMncConfiguration(mContext, operatorNumeric, false);
-                        }
-                    }
-                } else {
-                    String operatorNumeric = getRUIMOperatorNumeric();
-                    log("NO update mccmnc=" + operatorNumeric);
-                }
-
-            break;
-
             case EVENT_GET_CDMA_SUBSCRIPTION_DONE:
                 ar = (AsyncResult)msg.obj;
                 String localTemp[] = (String[])ar.result;
@@ -844,9 +865,6 @@ public class RuimRecords extends IccRecords {
 
         if (DBG) log("fetchRuimRecords " + mRecordsToLoad);
 
-        mCi.getIMSIForApp(mParentApp.getAid(), obtainMessage(EVENT_GET_IMSI_DONE));
-        mRecordsToLoad++;
-
         mFh.loadEFTransparent(EF_ICCID,
                 obtainMessage(EVENT_GET_ICCID_DONE));
         mRecordsToLoad++;
-- 
2.19.1


From bfd99285c3a4adc62ecc0ee364be8a0a204b6838 Mon Sep 17 00:00:00 2001
From: dianlujitao <dianlujitao@lineageos.org>
Date: Wed, 14 Nov 2018 18:52:33 +0800
Subject: [PATCH 7/7] LocaleTracker: Add null check before accessing
 WifiManager

 * WiFi service is not considered as a core service so it won't start in
   min framework, but LocaleTracker accesses to WiFi service's API.
   This would lead to a fatal exception and trigger RescueParty.
 * Add null check before accessing WifiManager to avoid the crash.

Change-Id: Ib1e9aef5a34cb8cfc33f7aa6f242807bc6ef2c46
Signed-off-by: Pranav Vashi <neobuddy89@gmail.com>
---
 src/java/com/android/internal/telephony/LocaleTracker.java | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/src/java/com/android/internal/telephony/LocaleTracker.java b/src/java/com/android/internal/telephony/LocaleTracker.java
index 996e288dc..4c6f89886 100644
--- a/src/java/com/android/internal/telephony/LocaleTracker.java
+++ b/src/java/com/android/internal/telephony/LocaleTracker.java
@@ -408,8 +408,11 @@ public class LocaleTracker extends Handler {
             // Set the country code for wifi. This sets allowed wifi channels based on the
             // country of the carrier we see. If we can't see any, reset to 0 so we don't
             // broadcast on forbidden channels.
-            ((WifiManager) mPhone.getContext().getSystemService(Context.WIFI_SERVICE))
-                    .setCountryCode(countryIso);
+            WifiManager wifiManager = (WifiManager) mPhone.getContext().getSystemService(
+                    Context.WIFI_SERVICE);
+            if (wifiManager != null) {
+                wifiManager.setCountryCode(countryIso);
+            }
         }
     }
 
-- 
2.19.1

